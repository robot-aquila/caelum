.. _binary_formats:

***********************
Двоичные форматы данных
***********************

Для ускорения обработки и сокращения объема используемых данных, некоторые данные сохраняются и передаются
в двоичном формате. В данном разделе описывается как данные представляются на низком уровне.


.. contents::
    :local:
    :depth: 2


Формат представления событий
============================

Двоичный формат представления событий используется при отправке и получении сообщений в топик событий кластера Kafka.
При этом, в качестве ключа используется символ, а в качестве времени сообщения - время слота событий.
Упаковываются только параметры событий.

По каждому событию формируется отдельная запись:

- Первый байт представляет собой заголовок пары.
    
    - бит 0 (*delete mark*) - если включен, указывает что это инструкция на удаление события. При этом, содержательная
      часть события (данные) не включается в запись. Если бит выключен, то это инструкция на добавление или обновление
      события. В этом случае запись содержит упакованные данные события.
    
    - биты 1-3 (*id bytes*) хранят длину идентификатора события в байтах минус один. То есть, 0 в этих трех битах
      указывает на длину в 1 байт. Когда все три бита включены (то есть значение 7), значит под идентификатор отводится
      8 байт.
	  
    - бит 4 (*reserved 1*) зарезервирован для будущего использования.
	
    - биты 5-7 (*data size bytes*) хранят количество байт длины содержательной части (длина строки данных) минус
      один. При этом, данные биты выключены, если *delete mark* включен.
	
- Следующие байты в количестве *id bytes* байт кодируют идентификатор события

Далее данные кодируются при условии, что *delete mark* выключен

- Следующие байты в количестве *data size bytes* кодируют длину содержательной части события. То есть, длину строки -
  *data size*.
- Следующие байты в количестве *data size* кодируют содержимое события

Записи всех событий слота объединяются в одну двоичную запись. Распаковка прекращается по достижения конца этой
комбинированной записи.


Basics
======

Symbol and time are keys and not considered as a part of packed binary record.
To avoid linking with external storages values are stored along with number of decimals.
To reach maximum compactness the records can be stored in different formats depends on actual data.
For example just 4 bytes may be enough to represent a lot of trades of typical stock-market security.
**Caelum** is optimized both to save the space and keep processing fast.


Item binary format
==================

Item contains two components: *value* and *volume*.
Each record starts with header which encodes a record type.
First lower 2 bits (rightmost) are:

- 0x00 - Reserved
- 0x01 - LONG_COMPACT
- 0x02 - LONG_REGULAR
- 0x03 - Reserved

*LONG_COMPACT* is for items that repsesents *value* in range 0-65535 and *volume* in range 0-63 with number
of decimals (both components) in range 0-15. The rest 6 bits of the first byte is an item *volume* which
is in range 0-63 inclusive. The next byte encodes number of decimals: lower 4 bits of *value* and higher 4
bits of *volume*. The next two bytes is *value* 0-65535. The record size of this type is fixed: 4 bytes.
*LONG_COMPACT* is suitable for most typycal trades which is quoted in US dollars (or something like that)
and can save lot of space.

*LONG_REGULAR* is for items that represents *value* and *volume* in range from -2^63 to 2^63-1
with number of decimals in range 0-15. The rest 6 bits of the first byte are used to encode size of
*value* and *volume* in bytes: bits 2-4 and 5-7 respectively. The size of component (*value* or *volume*)
cannot be less than 1 byte. Maximum size of component is 8 bytes. To encode such range the size is reduced by
one. So the encoded size of 0 equals to size of 1 byte, 1 to size of 2 bytes and so on, 7 is size of 8
bytes. The next byte of *LONG_REGULAR* record encodes number of decimals: lower 4 bits of *value* and
higher 4 bits of *volume*. The next bytes are compacted representation of *value* (1-8 bytes). And the next
bytes are compacted *volume*. Minimal record size of this type is 4 bytes: 1 for header, 1 for number of
decimals, 1 for *value* and 1 for *volume*. The maximum record size is 18 bytes. 


Бинарный формат кортежа OHLCV
=============================

Кортеж OHLCV состоит из пяти числовых элементов: *open*, *high*, *low*, *close* (группа *OHLC*) и *volume*. Бинарный
формат позволяет сохранять данные кортежа в широком диапазоне значений: количество байт выделенных на хранение
отдельного элемента кортежа находится в пределах от 1 до 2^31-1, а точность может находиться в пределах от -2^31 до
2^31-1. Данный формат оптимизирован для хранения большого количества записей и предусматривает несколько вариантов
упаковки полей, позволяющих представлять данные в максимально компактной форме.

Формат предполагает раздельное хранение информации о количестве десятичных знаков (точности) и значений элементов.
Элементы кортежа хранятся в виде целочисленных значений с сетевым порядком следования байтов (BigEndian,
network byte order), что позволяет использовать стандартные алгоритмы Java для упаковки и распаковки полей. Количество
десятичных знаков для значений группы *OHLC* и значения *volume* указываются обособленно. То есть, точность значений
*OHLC* и *volume* может различаться, но внутри группы *OHLC* точность одинакова для всех элементов.

Бинарную запись кортежа *OHLCV* можно условно разбить на четыре секции:

 +---------------+----------------------------------------------+
 | Секция        | Расшифровка                                  |
 +===============+==============================================+
 | *header*      | Заголовок записи                             |
 +---------------+----------------------------------------------+
 | *decimals*    | Информация о точности значений (опционально) |
 +---------------+----------------------------------------------+
 | *ohlc data*   | Данные группы *OHLC* без учета точности      |
 +---------------+----------------------------------------------+
 | *volume data* | Данные *volume* без учета точности           |
 +---------------+----------------------------------------------+

Ниже подробнее рассматривается каждая из секций.

Заголовок записи
----------------

Заголовок представляет собой группу полей, определяющих значения или положение других полей внутри записи.
Прочитав заголовок, можно определить положение любого поля и количество байт, представляющих значение этого поля.
В некоторых случаях заголовок хранит информацию о значениях полей. Для определения способа хранения конкретных полей
используются флаговые биты заголовка. 

Заголовок можно условно разделить на следующие поля в порядке следования:

 +------------------+-------------+--------------------------------------------+
 | Поле             | Размер байт | Расшифровка                                |
 +==================+=============+============================================+
 | *hdr_byte1*      | 1           | Опорный заголовочный байт                  |
 +------------------+-------------+--------------------------------------------+
 | *hdr_open_high*  | 1           | Способ кодирования и длины *open* и *high* |
 +------------------+-------------+--------------------------------------------+
 | *hdr_low_close*  | 1           | Способ кодирования и длины *low* и *close* |
 +------------------+-------------+--------------------------------------------+
 | *hdr_ohlc_sizes* | 4+          | Длины группы *OHLC* (опционально)          |
 +------------------+-------------+--------------------------------------------+

Первый байт заголовка *hdr_byte1* определяет алгоритм упаковки и некоторые параметры записи

 +-----+------------------+-------------------------------------------+
 | Бит | Код              | Расшифровка                               |
 +=====+==================+===========================================+
 | 0   | *hdr_mp_dcm*     | Способ упаковки информации о точности     |
 +-----+------------------+-------------------------------------------+
 | 1   | *hdr_mp_ohlc*    | Способ кодирования значений группы *OHLC* |
 +-----+------------------+-------------------------------------------+
 | 2-4 | *hdr_dcm_ohlc*   | Точность группы *OHLC* (см. *hdr_mp_dcm*) |
 +-----+------------------+-------------------------------------------+
 | 5-7 | *hdr_dcm_volume* | Точность *volume* (см. *hdr_mp_dcm*)      |
 +-----+------------------+-------------------------------------------+

Бит *hdr_mp_dcm* определяет способ упаковки количества десятичных знаков (точности).

Если точность в кортеже находится в пределах от 0 до 7 для обеих групп, то данный бит выключен (равен 0). В этом случае
точность кодируется в полях *hdr_dcm_ohlc* и *hdr_dcm_volume*, а секция *decimals* записи отсутствует (то есть, за
заголовком *header* сразу следует секция *ohlc data*).

Если точность в кортеже хотя бы для одной группы находится за пределами диапазона от 0 до 7, то бит *hdr_mp_dcm* включен
(равен 1). В этом случае точность кодируется в секции *decimals* записи (следующая после *header*). При этом,
*hdr_dcm_ohlc* указывает на количество байт выделенных для хранения значения точности для группы *OHLC* минус 1, а
*hdr_dcm_volume* - на количество байт под хранение точности значения *volume* минус 1.

.. note::
    Фактически, формат позволяет работать с 64 битными значениями для выражения точности и длины элементов в байтах.
    Однако, такие требования кажутся избыточными и не поддерживаются основными классами Java (выражение размеров
    структур опирается на тип int). В связи с этим, для данных параметров используется условное ограничение в 32 бита
    при сохранении возможности адаптации к 64 битам без изменения основного алгоритма.

Бит *hdr_mp_ohlc* определяет способ кодирования значений группы *OHLC*.

Если элементы группы *OHLC* могут быть упакованы в поля не более 8 байт, то этот бит выключен (равен 0). В этом случае,
поля *hdr_open_high* и *hdr_low_close* содержат информацию о длине полей соответствующих элементов группы *OHLC* в
байтах. При этом, секция *hdr_ohlc_sizes* в заголовке отсутствует.

Если для упаковки элементов из группы *OHLC* 8 байт недостаточно, то бит *hdr_mp_ohlc* включен (равен 1). В этом
случае поля *hdr_open_high* и *hdr_low_close* содержат информацию о размере полей, зарезервированных для хранения
длин соответствующих элементов (то есть, буквально - длина длины). При этом, заголовок включает в себя секцию
*hdr_ohlc_sizes*, в которой последовательно сохраняются длины соответственно элемента *open*, *high*, *low* и *close*.

Следующие два байта заголовка *hdr_open_high* и *hdr_low_close* фактически кодируют 4 последовательных поля: по 4 бита
для каждого компонента *open*, *high*, *low* и *close*. Старшие 4 бита *hdr_open_high* представляют параметры *open*,
младшие 4 бита *hdr_open_high* - параметры *high*. Старшие 4 бита *hdr_low_close* представляют параметры *low*,
младшие 4 бита *hdr_low_close* - соответственно параметры *close*. Каждое из полей расшифровывается следующим образом

 +-----+------------+-------------------------+
 | Бит | Код        | Расшифровка             |
 +=====+============+=========================+
 | 0   | *relative* | Отношение к *open*      |
 +-----+------------+-------------------------+
 | 1-3 | *size*     | Размер в байтах минус 1 |
 +-----+------------+-------------------------+

Бит *relative* определяет отношение значения к элементу *open* кортежа. Элементы *high*, *low* и *close* кортежа могут
быть выражены как в абсолютных значениях, так и в относительных по отношению к *open* (в связи с чем, значение
*relative* для *open* всегда равно 0). Если бит *relative* выключен (равен 0), то соответствующее значение записано
в абсолютном выражении. Если бит *relative* включен (равен 1), то соответствующее значение выражено в виде разницы
по отношению к значению элемента *open* и для его восстановления требуется сложить упакованное значение со значением
*open* кортежа. Подобный подход позволяет использовать более компактную запись в тех случаях, когда арифметическая
разница между элементами группы *OHLC* в бинарном виде занимает меньше месте, чем бинарное представление абсолютной
величины.

Биты поля *size* интерпретируются в зависимости от *hdr_mp_ohlc* заголовка. Если *hdr_mp_ohlc* выключен, то значения
элементов группы *OHLC* могут быть упакованы в поля не более 8 байт длиной. В этом случае *size* содержит длину поля
элемента в байтах минус 1, а секция *hdr_ohlc_sizes* в заголовке отсутствует. Если *hdr_mp_ohlc* включен, то *size*
кодирует сколько байт (за вычетом единицы, то есть - не меньше 1 байта) требуется для хранения длины соотствующего
элемента, а сами длины кодируются в заголовке в секции *hdr_ohlc_sizes*.

Секция *hdr_ohlc_sizes* заголовка является опциональной и включается в заголовок только в случае, если в группе *OHLC*
есть хотя бы один элемент, который не может быть упакован в поле 8 байтной длины. В этом случае секция *hdr_ohlc_sizes*
содержит последовательно байты длины соответствующего элемента группы *OHLC* в порядке следования *open*, *high*, *low*
и *close*. Количество байт выделенных для хранения длины соответствующего элемента определяется на основании содержимого
*size* соответствующего поля в составе *hdr_open_high* или *hdr_low_close*.

Таким образом, минимальный размер заголовка равен 3, а максимальный 19 байтам: 3 байта на обязательные поля плюс по 4
байта максимум (исходя из ограничения в 32 бита) на хранение размера элементов *OHLC*.

Информация о точности значений
------------------------------

Секция *decimals* включается в запись только в том случае, если для значений группы *OHLC* или *volume* точность
находится вне диапазона от 0 до 7 десятичных знаков. Размер этой секции в байтах определяется суммой значений
*hdr_dcm_ohlc* и *hdr_dcm_volume* поля *hdr_byte1* заголовка (не забываем, что эти значения записаны с вычетом единицы).
Сначала следуют байты значения точности группы *OHLC* в количестве *hdr_dcm_ohlc* + 1, затем байты значения точности
*volume* в количестве *hdr_dcm_volume* + 1.

Данные группы *OHLC* без учета точности
---------------------------------------

В секции *ohlc data* упакованы данные группы *OHLC* в порядке следования: *open*, *high*, *low* и *close*.
Элемент *open* всегда сохраняется в абсолютном выражении, а элементы *high*, *low* и *close* могут быть записаны как
в абсолютном выражении, так и в виде разницы относительно элемента *open*. Для определения способа кодирования *high*,
*low* и *close* (относительного *open* или абсолютного) следует обратиться к соответствующим полям *relative* значений
байтов *hdr_open_high* и *hdr_low_close* заголовка. Количество байт, зарезервированных под конкретный элемент группы
*OHLC* определяется на основании данных заголовка. Если в составе группы нет элементов превышающих 8 байт в упакованном
виде, то размеры определяются на основании информации из *hdr_open_high* и *hdr_low_close* заголовка. Если же в составе
группы есть элементы, которые в упакованном виде занимают более 8 байт, то размер соответствующих полей определяется
на основании секции *hdr_ohlc_sizes* заголовка. 

Данные *volume* без учета точности
----------------------------------

В секции *volume data* бинарной записи кортежа сохраняется информация о суммарном объеме, выраженном в целочисленной
форме. Размер данной секции определяется по остаточному принципу: все байты записи, оставшиеся после секции *ohlc data*
относятся к значению *volume*.



TODO: refactoring

Each record starts with header wich encodes a record type.
First 2 bits are:

- 0x00 - Reserved
- 0x01 - Reserved
- 0x02 - LONG_REGULAR or LONG_WIDEVOL
- 0x03 - Reserved

*LONG_REGULAR* is for tuples where components are in range from -2^63 to 2^63-1 and number of decimals
in range 0-15. *LONG_WIDEVOL* is mostly same except that *volume* can be greater size than 8 bytes.
For *LONG_REGULAR*  the next 3 bits (2-4) encodes the size of *volume* in bytes minus one. For *LONG_WIDEVOL*
bits 2-4 of the first byte are always on and size of *volume* determined by remaining length of the record.
If remaining length is greater than 8 then *BigInteger* type will be used to represent *volume*.
The last bits of the first byte are reserved (5-7). The next byte encodes number of decimals: lower 4 bits
of *OHLC* and higher 4 bits of *volume*.

The next byte encodes type and size of *open* and *high* components: 4 bits per component. The bit 0 is
reserved. Bits 1-3 encodes the size of *open* component in bytes minus 1. Bit 4 represents type of encoding
of *high* component: if bit is off then absolute value if bit is on then relative to *open* component.
Bits 5-7 are size of *high* in bytes minus 1. The next byte encodes type and size of *low* and *close*
components like as previous byte: 4 bits per component, the lower one bit is the type (0 - absolute, 1 -
relative to *open*), the rest 3 bits is the size in bytes minus 1. The next bytes are bytes of components
in order: *open*, *high*, *low*, *close*, *volume* respectively sizes from header.

The header total size is 4 bytes: record type and size of *volume*, number of decimals, *open* and *high*
params, *low* and *close* params. Minimal record size is 9 bytes. Maximum size is 44 if there is
*LONG_REGULAR* record type and unlimited if there is *LONG_WIDEVOL*. 

