.. _binary_formats:

***********************
Бинарные форматы данных
***********************

Для ускорения обработки и сокращения объема занимаемых данных, некоторые данные представляются в бинарной форме. В этом
разделе описываются бинарные форматы представления объектов системы.


.. contents::
    :local:
    :depth: 2


Формат представления событий
============================

Двоичный формат представления событий используется при отправке и получении сообщений в топик событий кластера Kafka.
При этом, в качестве ключа используется символ, а в качестве времени сообщения - время слота событий.
Упаковываются только параметры событий.

По каждому событию формируется отдельная запись:

- Первый байт представляет собой заголовок пары.
    
    - бит 0 (*delete mark*) - если включен, указывает что это инструкция на удаление события. При этом, содержательная
      часть события (данные) не включается в запись. Если бит выключен, то это инструкция на добавление или обновление
      события. В этом случае запись содержит упакованные данные события.
    
    - биты 1-3 (*id bytes*) хранят длину идентификатора события в байтах минус один. То есть, 0 в этих трех битах
      указывает на длину в 1 байт. Когда все три бита включены (то есть значение 7), значит под идентификатор отводится
      8 байт.
	  
    - бит 4 (*reserved 1*) зарезервирован для будущего использования.
	
    - биты 5-7 (*data size bytes*) хранят количество байт длины содержательной части (длина строки данных) минус
      один. При этом, данные биты выключены, если *delete mark* включен.
	
- Следующие байты в количестве *id bytes* байт кодируют идентификатор события

Далее данные кодируются при условии, что *delete mark* выключен

- Следующие байты в количестве *data size bytes* кодируют длину содержательной части события. То есть, длину строки -
  *data size*.
- Следующие байты в количестве *data size* кодируют содержимое события

Записи всех событий слота объединяются в одну двоичную запись. Распаковка прекращается по достижения конца этой
комбинированной записи.


Basics
======

Symbol and time are keys and not considered as a part of packed binary record.
To avoid linking with external storages values are stored along with number of decimals.
To reach maximum compactness the records can be stored in different formats depends on actual data.
For example just 4 bytes may be enough to represent a lot of trades of typical stock-market security.
**Caelum** is optimized both to save the space and keep processing fast.

Бинарные форматы позволяют хранить данные в широком диапазоне величин. Числовые значения представляются в виде
последовательности байт условно-неограниченной длины. Точность (количество десятичных знаков) числовых значений
находится в диапазоне от -2^31 до 2^31-1. Большинство полей предусматривают размеры от 0 до 2^31-1 байт. Однако хранение
поля размером 2^31-1 не представляется возможным в виду ограничения общего размера записи в 2^31-1 байт. А так как
помимо непосредственно значения поля запись содержит и другие данные, объем доступного пространства внутри записи всегда
меньше 2^31-1 байт. Подобный подход выбран намерено, что бы обеспечить максимальную гибкость распределения пространства
в зависимости от потребностей.


Бинарный формат пункта
======================

Пункт представляет собой структуру данных, состоящую из пары числовых показателей: качественного *value*,
количественного *volume* и произвольных данных *custom data*. При упаковке в запись все три элемента данных являются
опциональными. Неопределенное значение *value* или нулевое значение *volume* рассматриваются как частные случаи,
могут использоваться для подавления соответствующих агрегатных функций, применяемых к значениям показателей, и не
требуют пространства для хранения. Размер поля *custom data* определяется по остаточному принципу и может быть нулевым.
Таким образом, минимальный размер записи пункта соответствует размеру его заголовка.

Бинарную запись пункта можно условно разделить на две части: заголовок и секцию данных. Ниже в деталях рассматривается
содержимое этих секций.

Заголовок записи
----------------

Заголовок представляет собой группу полей, определяющих значения или положение других полей внутри записи. Прочитав
заголовок можно определить наличие, размер и положение любого поля данных внутри записи. Заголовок условно разделяется
на следующие блоки в порядке их следования:

 +----------------+-------------+--------------------------------------+
 | Поле           | Размер байт | Расшифровка                          |
 +================+=============+======================================+
 | *hdr_byte1*    | 1           | Опорный заголовочный байт            |
 +----------------+-------------+--------------------------------------+
 | *hdr_valvol*   | 1           | Детали кодирования полей данных      |
 +----------------+-------------+--------------------------------------+
 | *hdr_sizes*    | 1+          | Длины полей данных (опционально)     |
 +----------------+-------------+--------------------------------------+
 | *hdr_decimals* | 2+          | Пара значений точности (опционально) |
 +----------------+-------------+--------------------------------------+

Первый байт заголовка *hdr_byte1* определяет алгоритм упаковки и некоторые параметры записи

 +-----+------------------+---------------------------------------------+
 | Бит | Код              | Расшифровка                                 |
 +=====+==================+=============================================+
 | 0   | *hdr_mp_dcm*     | Способ упаковки информации о точности       |
 +-----+------------------+---------------------------------------------+
 | 1   | *hdr_mp_valvol*  | Способ кодирования полей *value* & *volume* |
 +-----+------------------+---------------------------------------------+
 | 2-4 | *hdr_dcm_value*  | Точность *value* (см. *hdr_mp_dcm*)         |
 +-----+------------------+---------------------------------------------+
 | 5-7 | *hdr_dcm_volume* | Точность *volume* (см. *hdr_mp_dcm*)        |
 +-----+------------------+---------------------------------------------+

Бит *hdr_mp_dcm* определяет наличие в заголовке секции *hdr_decimals* и фактически определяет способ упаковки количества
десятичных знаков (точности). Если точность значений *value* и *volume* лежит в пределах от 0 до 7, то данный бит
выключен (равен 0). В этом случае точность кодируется в полях *hdr_dcm_value* и *hdr_dcm_volume*, а секция
*hdr_decimals* в заголовке отсутствует. Если точность *value* или *volume* находится за пределами диапазона от 0 до 7,
то бит *hdr_mp_dcm* включен (равен 1). В этом случае точность кодируется в секции заголовка *hdr_decimals*, а поля
*hdr_dcm_value* и *hdr_dcm_volume* указывают на количество байт выделенных на хранение точности соответственно *value* и
*volume* минус 1. То есть, не меньше 1 байта и не больше 8.

Бит *hdr_mp_valvol* служит индикатором наличия в заголовке секции *hdr_sizes*. Если значения *value* и *volume* могут
быть упакованы в поля не более 8 байт, то данный бит выключен (равен 0). В этом случае *hdr_valvol* содержит информацию
о длине соответствующих полей. Если же для бинарного представления *value* или *volume* требуется более 8 байт на поле,
то данный бит включен (равен 1). В этом случае *hdr_valvol* содержит информацию о размере полей, зарезервированных для
хранения длин соответствующих элементов (то есть, буквально - длина длины).


Второй байт заголовка *hdr_valvol* кодирует информацию о наличии и размере *value* и *volume*. Ниже указано как группы
бит кодируют соответствующую информацию:

 +-----+------------------+-----------------------------------+
 | Бит | Код              | Расшифровка                       |
 +=====+==================+===================================+
 | 0   | *volume_present* | Наличие *volume*                  |
 +-----+------------------+-----------------------------------+
 | 1-3 | *volume_size*    | Размер *volume* в байтах минус 1  |
 +-----+------------------+-----------------------------------+
 | 4   | *value_present*  | Наличие *value*                   |
 +-----+------------------+-----------------------------------+
 | 5-7 | *value_size*     | Размер *value* в байтах минус 1   |
 +-----+------------------+-----------------------------------+

Бит *volume_present* определяет наличие в секции данных значения *volume*. Если этот бит выключен (равен 0), то *volume*
равно нулю и под хранение этого значения место не резервируется. Если этот бит включен (равен 1), то значение *volume*
записано в секции данных.

Поле *volume_size* используется для определения длины значения *volume* и интерпретируется в зависимости от
*hdr_mp_valvol* заголовка: если *hdr_mp_valvol* включен, то размер блока *volume* определяется соответствующей записью в
секции *hdr_sizes*, а *volume_size* указывает на размер этой записи минус 1; если *hdr_mp_valvol* выключен,
*volume_size* указывает непосредственно на размер блока *volume* минус 1. Если *volume_present* равно нулю, то все биты
этого поля выключены.

Бит *value_present* определяет наличие в секции данных значения *value*. Если этот бит выключен (равен 0), то значение
*value* пункта не определено и не требует места для хранения. Если этот бит включен (равен 1), то значение *value*
записано в секции данных.

Поле *value_size* определяет длину значения *value* и интерпретируется в зависимости от *hdr_mp_valvol* заголовка. Если
*hdr_mp_valvol* включен, то размер блока *value* в секции данных определяется соответствующей записью в секции
*hdr_sizes*, а *value_size* указывает на размер этой записи минус 1; если *hdr_mp_valvol* выключен, *value_size*
указывает непосредственно на размер блока *value* минус 1. Если *value_present* равно нулю, то все биты этого поля
выключены.


Далее следуют данные секции размеров *hdr_sizes*. Эта секция присутствует в заголовке, если включен бит *hdr_mp_valvol*
первого байта заголовка. В этой секции последовательно кодируется длины *value* и *volume*. При этом, длина *value*
в этой секции отсутствует, если в *hdr_valvol* заголовка выключен бит *value_present*. Длина *volume* в этой секции
отсутствует, если в *hdr_valvol* выключен бит *volume_present*.


Секция *hdr_decimals* включается в заголовок только в том случае, если точность *value* или *volume* находится вне
диапазона от 0 до 7 десятичных знаков. Сначала секции записываются байты значения точности *value* в количестве
*hdr_dcm_value* + 1, затем байты значения точности *volume* в количестве *hdr_dcm_volume* + 1.


Секция данных
-------------

Секция данных расположена сразу за заголовком и содержит блоки данных *value*, *volume* и *custom data*, упакованные в
единую последовательность. При этом, наличие в секции блока *value* зависит от состояния *value_present*, а блока
*volume* от *volume_present*, определенных во втором байте заголовка *hdr_valvol*. Размер блока *custom_data*
определяется по остаточному принципу как разница размера секции и суммы размеров блоков *value* и *volume*. 


Бинарный формат кортежа OHLCV
=============================

Кортеж OHLCV состоит из пяти числовых элементов: *open*, *high*, *low*, *close* (группа *OHLC*) и *volume*.
Данный формат оптимизирован для хранения большого количества записей и предусматривает несколько вариантов
упаковки полей, позволяющих представлять данные в максимально компактной форме.

Формат предполагает раздельное хранение информации о количестве десятичных знаков (точности) и значений
элементов. Элементы кортежа хранятся в виде целочисленных значений с сетевым порядком следования байтов
(BigEndian, network byte order), что позволяет использовать стандартные алгоритмы Java для упаковки и
распаковки полей. Количество десятичных знаков для значений группы *OHLC* и значения *volume* указываются
обособленно. То есть, точность значений *OHLC* и *volume* может различаться, но внутри группы *OHLC*
точность одинакова для всех элементов.

Бинарную запись кортежа *OHLCV* можно условно разбить две части: заголовок и секцию данных. Заголовок
содержит информацию о точности, размерах элементов секции полезной нагрузки и позволяет находить указатель
на поле хранения каждого элемента данных кортежа. Секция данных хранит значения элементов кортежа.

Далее подробно рассматривается каждая из секций.

Заголовок записи
----------------

Заголовок представляет собой группу полей, определяющих значения или положение других полей внутри записи.
Прочитав заголовок, можно определить положение любого поля и количество байт, представляющих значение этого
поля. В некоторых случаях заголовок хранит информацию о значениях полей. Для определения способа хранения
конкретных полей используются флаговые биты заголовка. 

Заголовок можно условно разделить на следующие секции в порядке следования:

 +------------------+-------------+-------------------------------------+
 | Поле             | Размер байт | Расшифровка                         |
 +==================+=============+=====================================+
 | *hdr_byte1*      | 1           | Опорный заголовочный байт           |
 +------------------+-------------+-------------------------------------+
 | *hdr_open_high*  | 1           | Способ кодирования *open* и *high*  |
 +------------------+-------------+-------------------------------------+
 | *hdr_low_close*  | 1           | Способ кодирования *low* и *close*  |
 +------------------+-------------+-------------------------------------+
 | *hdr_ohlc_sizes* | 4+          | Длины группы *OHLC* (опционально)   |
 +------------------+-------------+-------------------------------------+
 | *hdr_decimals*   | 2+          | Пара значений точности (опционально)|
 +------------------+-------------+-------------------------------------+


Первый байт заголовка *hdr_byte1* определяет алгоритм упаковки и некоторые параметры записи

 +-----+------------------+-------------------------------------------+
 | Бит | Код              | Расшифровка                               |
 +=====+==================+===========================================+
 | 0   | *hdr_mp_dcm*     | Способ упаковки информации о точности     |
 +-----+------------------+-------------------------------------------+
 | 1   | *hdr_mp_ohlc*    | Способ кодирования значений группы *OHLC* |
 +-----+------------------+-------------------------------------------+
 | 2-4 | *hdr_dcm_ohlc*   | Точность группы *OHLC* (см. *hdr_mp_dcm*) |
 +-----+------------------+-------------------------------------------+
 | 5-7 | *hdr_dcm_volume* | Точность *volume* (см. *hdr_mp_dcm*)      |
 +-----+------------------+-------------------------------------------+

Бит *hdr_mp_dcm* определяет способ упаковки количества десятичных знаков (точности).

Если точность в кортеже находится в пределах от 0 до 7 для обеих групп, то данный бит выключен (равен 0).
В этом случае точность кодируется в полях *hdr_dcm_ohlc* и *hdr_dcm_volume*, а секция *hdr_decimals* в
заголовке отсутствует.

Если точность в кортеже хотя бы для одной группы находится за пределами диапазона от 0 до 7, то бит *hdr_mp_dcm* включен
(равен 1). В этом случае точность кодируется в секции заголовка *hdr_decimals*. При этом, *hdr_dcm_ohlc* указывает
на количество байт выделенных для хранения значения точности для группы *OHLC* минус 1, а *hdr_dcm_volume* - на
количество байт под хранение точности значения *volume* минус 1.

.. note::
    Фактически, формат позволяет работать с 64 битными значениями для выражения точности и длины элементов в байтах.
    Однако, такие требования кажутся избыточными и не поддерживаются основными классами Java (выражение размеров
    структур опирается на тип int). В связи с этим, для данных параметров используется условное ограничение в 32 бита
    при сохранении возможности адаптации к 64 битам без изменения основного алгоритма.

Бит *hdr_mp_ohlc* определяет способ кодирования значений группы *OHLC*. Если элементы группы *OHLC*
могут быть упакованы в поля не более 8 байт, то этот бит выключен (равен 0). В этом случае, поля
*hdr_open_high* и *hdr_low_close* содержат информацию о длине полей соответствующих элементов
группы *OHLC* в байтах. При этом, секция *hdr_ohlc_sizes* в заголовке отсутствует.

Если для упаковки элементов из группы *OHLC* 8 байт недостаточно, то бит *hdr_mp_ohlc* включен (равен 1). В этом
случае поля *hdr_open_high* и *hdr_low_close* содержат информацию о размере полей, зарезервированных для хранения
длин соответствующих элементов (то есть, буквально - длина длины). При этом, заголовок включает в себя секцию
*hdr_ohlc_sizes*, в которой последовательно сохраняются длины соответственно элемента *open*, *high*, *low* и *close*.


Следующие два байта заголовка *hdr_open_high* и *hdr_low_close* фактически кодируют 4 последовательных поля: по 4 бита
для каждого компонента *open*, *high*, *low* и *close*. Старшие 4 бита *hdr_open_high* представляют параметры *open*,
младшие 4 бита *hdr_open_high* - параметры *high*. Старшие 4 бита *hdr_low_close* представляют параметры *low*,
младшие 4 бита *hdr_low_close* - соответственно параметры *close*. Каждое из полей расшифровывается следующим образом

 +-----+------------+-------------------------+
 | Бит | Код        | Расшифровка             |
 +=====+============+=========================+
 | 0   | *relative* | Отношение к *open*      |
 +-----+------------+-------------------------+
 | 1-3 | *size*     | Размер в байтах минус 1 |
 +-----+------------+-------------------------+

Бит *relative* определяет отношение значения к элементу *open* кортежа. Элементы *high*, *low* и *close* кортежа могут
быть выражены как в абсолютных значениях, так и в относительных по отношению к *open* (в связи с чем, значение
*relative* для *open* всегда равно 0). Если бит *relative* выключен (равен 0), то соответствующее значение записано
в абсолютном выражении. Если бит *relative* включен (равен 1), то соответствующее значение выражено в виде разницы
по отношению к значению элемента *open* и для его восстановления требуется вычесть упакованное значение из значения
*open* кортежа. Подобный подход позволяет использовать более компактную запись в тех случаях, когда арифметическая
разница между элементами группы *OHLC* в бинарном виде занимает меньше месте, чем бинарное представление абсолютной
величины.

Биты поля *size* интерпретируются в зависимости от *hdr_mp_ohlc* заголовка. Если *hdr_mp_ohlc* выключен, то значения
элементов группы *OHLC* могут быть упакованы в поля не более 8 байт длиной. В этом случае *size* содержит длину поля
элемента в байтах минус 1, а секция *hdr_ohlc_sizes* в заголовке отсутствует. Если *hdr_mp_ohlc* включен, то *size*
кодирует сколько байт (за вычетом единицы, то есть - не меньше 1 байта) требуется для хранения длины соотствующего
элемента, а сами длины кодируются в заголовке в секции *hdr_ohlc_sizes*.

Секция *hdr_ohlc_sizes* заголовка является опциональной и включается в заголовок только в случае, если в группе *OHLC*
есть хотя бы один элемент, который не может быть упакован в поле 8 байтной длины. В этом случае секция *hdr_ohlc_sizes*
содержит последовательно байты длины соответствующего элемента группы *OHLC* в порядке следования *open*, *high*, *low*
и *close*. Количество байт выделенных для хранения длины соответствующего элемента определяется на основании содержимого
*size* соответствующего поля в составе *hdr_open_high* или *hdr_low_close*.

Секция *hdr_decimals* включается в заголовок только в том случае, если для значений группы *OHLC* или *volume* точность
находится вне диапазона от 0 до 7 десятичных знаков. Размер этой секции в байтах определяется суммой значений
*hdr_dcm_ohlc* и *hdr_dcm_volume* поля *hdr_byte1* заголовка (следует помнить, что эти значения записаны с вычетом
единицы). Сначала следуют байты значения точности группы *OHLC* в количестве *hdr_dcm_ohlc* + 1, затем байты значения
точности *volume* в количестве *hdr_dcm_volume* + 1.

Таким образом, минимальный размер заголовка равен 3, а максимальный 27 байтам: 3 байта на обязательные поля плюс по 4
байта максимум (исходя из ограничения в 32 бита) на хранение размера элементов *OHLC* плюс еще пара по 4 байта на
хранение точности.


Секция данных
-------------

Секция данных расположена сразу за заголовком и содержит упакованные данные элементов кортежа. Сначала сохраняются
элементы группы *OHLC* в порядке следования: *open*, *high*, *low* и *close*. Элемент *open* всегда сохраняется в
абсолютном выражении, а элементы *high*, *low* и *close* могут быть записаны как в абсолютном выражении, так и в
виде разницы относительно элемента *open*. Для определения способа кодирования *high*, *low* и *close*
(относительного *open* или абсолютного) следует обратиться к соответствующим полям *relative* значений байтов
*hdr_open_high* и *hdr_low_close* заголовка. Количество байт, зарезервированных под конкретный элемент группы
*OHLC* определяется на основании данных заголовка. Если в составе группы нет элементов превышающих 8 байт в
упакованном виде, то размеры определяются на основании информации из *hdr_open_high* и *hdr_low_close* заголовка.
Если же в составе группы есть элементы, которые в упакованном виде занимают более 8 байт, то размер соответствующих
полей определяется на основании секции *hdr_ohlc_sizes* заголовка. 

Далее следует поле *volume* без учета точности. Размер данного поля определяется по остаточному принципу: все байты
записи, начиная с первого следующего за полем *close* и до конца записи относятся к значению *volume*.
