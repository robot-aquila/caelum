TODO: Нужно продумать горячий запуск/останов фидера? Продумать механизм,
как работать с дублирующими фидерами. Но в MVP этим заморачиваться вероятно не
стоит? Можно сделать сохранение в отдельные топики на фидер, обеспечивая тем
самым необходимую избыточность данных. Консумер может отслеживать группу
топиков, комбинируя в случае необходимости данные из разных фидеров. Потерь
данных не будет, пока работает хотя бы один фидер. Можно конекаться к разным
конечным точкам, так что если даже у провайдера будет сбой на одном сервере,
система поедет на оставшемся фидере.

TODO: Нужен список инструментов.

Реализация узлов.

1) Наиболее быстрый для мамбы, взять aquila-transaq, навешать на терминальные
события отлов сделок, конвертировать их в json вида [ id, time, price, vol ]
и пулять в кафку под разные топики, соответствующие разным инструментам.
Подписываться при старте на все символы. Делать реконнект и реподписку при
обрывах. В какие моменты и какими событиями обновляется список инструментов
пока неизвестно. Даст ли провайдер подписаться на 40к фидов и влезет ли такой
объем в один процесс, также неизвестно.

2) Заюзать kafka streming API. Навешать на фиды сначала агрегатор, который из
избыточных данных восстановит последовательность сделок, а затем агрегатор
который из тиковых данных налепит M1 свечки и выше. Вероятно, выше D1 сохранять
свечки особого смысла нет, Но можно и сохранить и тогда на выходных узлах вообще
не будет никакой логики кроме чтения и они будут работать максимально быстро.
Здесь так же надо построить индексы, которые позволят быстро ориентироваться
в последовательности и определять с какой записи какой временной период
начинается. Индексы еще следует продумать.

3) Видимо, REST апи для получения исторических данных. Можно взять spring boot
и налепить контроллеров. Всего их будет два:
1) Для получения тиковых данных за период от и до
2) Для получения свечек. Тут кроме периода от клиента понадобится еще таймфрейм.
Для MVP интерфейсы делать открытыми, а потом навешивать авторизацию.
Для real-time REST не подходит. Если нужно реалтайм, то нужны потоковые
протоколы.


TODO: Ключи можно использовать для раскидывания данных по партициям. Для сделок
это, видимо, не подходит. Но можно раскидать свечки.

TODO: Подзадача 1! Сборка данных из нескольких подающих фидеров в одну
последовательность сделок в реальном времени. Перезаписывать по ключам нельзя
ибо это меняет позицию.


TODO: кафка
TimestampExtractor 
processing.guarantee config value to exactly_once
Out-of-Order Handling (запоздавшие таймстампы)
See num.standby.replicas in the Kafka Streams Configs section.



TODO:

Нужна полная инфа о сделках для реплея.

Индексы:
Индексы надо хранить отдельно. Тогда можно легко расширять и добавлять новые.
Если хранить вместе, то придется при каждом изменении структуры индексов
перелопачивать уже существующие.

Допустим, минутный индекс на сделки даст ровно 24*60=1440 записей в сутки.
Индекс за день можно хранить целиком в бинарном виде, читать в виде отдельных
записей. Для указания на конкретный день можно сделать индекс второго уровня,
но лучше попробовать связать с индексом записи в партиции.
Для мосбиржи можно сжать.

Проблема с потоковым хранением индексов заключается в невозможности перезаписи
произвольной записи.



С индексами решено - кафка поддерживает. см. Consumer#offsetsForTimes

Таймстампы есть, индексы есть, ключи = тикеры.
По ключу можно определить партицию (забыл для чего это нужно)

Осталось разобраться:

*) Как хранить сделки - в отдельных топиках или в общем?
У общего есть плюсы:
 - можно разбивать на партиции и не париться вообще про топики
 - можно будет делать стримы из одного топика - они будут норм масштабироваться
Но и минусы:
 - данные разных символов будут смешаны и придется фильтровать на выдаче по
 символу. Хотя, если будет хорошо раскидано по партициям, то должно быть норм.
 - нельзя определить список символов обзором топиков
В случае отдельных топиков минусы:
 - непонятно как роутить из общей очереди если работать процессором
Плюсы:
 - топик содержит тикер и можно напрямую обратиться к данным тикера
 - данные хранятся обособлено и не будет оверхеда на пропуск ненужных символов.
 Но если будет много партиций, то это будет небольшая проблема, так как символы
 будут раскиданы по партициям.
 
*) Список инструментов.
Можно сделать таблицу в которую собирать инфу о прокаченных записях.
Но для поиска по ключу нужно будет отбирать стримом. Неизвестно насколько
это будет эффективно.

Насчет того, откуда брать данные для списка инструментов. Делать эту таблицу на
базе сделок вероятно смысла нет. Сделки у нас существуют отдельно и могут жить
самостоятельно. Хотя для дальнейшего процессинга уже нужна точность. В реальном
времени все равно сначала мы получаем параметры инструмента, а затем идут тики.
Но что делать, если какой то лаг будет при получении параметров? Кстати, для
параметров тоже можно сделать широкую таблицу (или хотя бы таблицу с точностью
и размером тика). В общем, список инструментов надо строить в процессе
сбора обновлений атрибутов.

Для списка инструментов compacted topic. Возможно из таблицы. Итак:
фидер слушает изменение состояний инструментов и постит события обновлений
в топик обновлений свойств. Ключами являются тикеры. Таймпстампы - время
соответствующее времени обновления параметров. Значением - карта обновленных
атрибутов. Этот топик будет использоваться для отбора обновлений на дату.
На этот топик навешиваем процессор, который маппит все в таблицу атрибутов
инструмента на последний момент.

Обновлений туда будет немного. Сделать 1 партицию? С 1 партицией чтение будет
идеально простым. С множеством партиций мы получим масштабирование, но как их
потом собирать в одну?

Таблица ведь не упорядочена. Для списка инструментов надо гарантировать
несменяемый порядок. Значит надо сделать через доптаблицу отдельный список.
Можно какое нибудь фиктивное значение типа 1 и убедиться, что обновления
единиц не будет вызывать появление записей в результирующем топике.

Итого:
1) топик с обновлениями инструментов с ключами-тикерами, хранит дельты
датированные временем обновления. Используется для реплея и восстановления.
2) таблица текущего состояния инструментов с ключами-тикерами, хранит
полное состояние, датированное временем последнего обновления. Используется
процессорами для быстрого получения текущих атрибутов.
3) таблица-список тикеров. 

Все компоненты:
- Список инструментов
- Поток обновлений атрибутов инструмента
- Поток сделок
- Поток свечей M1
- Фидер ММВБ
- Сериализатор сделок

Список инструментов.
1 партиция. Максимальное время хранения.
Записи добавляются в порядке появления инструментов в системе.
Источник - любой топик, где ключи - полный символ.
На основе потока из этого топика
groupByKey().count().filter((k, v) -> { v == 1 }).toStream().to(target-topic);
В результате топик будет заполняться записями, где ключи это символы.
Порядок записей будет постоянным и к ним можно обращаться по смещению.

Поток обновлений атрибутов инструмента
Произвольное кол-во партиций. Максимальное время хранения.
Первая запись содержит снепшот. Последующие записи содержат список измененных
атрибутов и новые значения. Ключи - полный символ. Время - время обновления
атрибутов.

Фидеры обновлений атрибутов инструмента

================================================================================
Бинарный формат представления сделки

Сырой формат оптимизирован как по памяти, так и под скорость.
Нам нужно хранить пару значений: цену и количество сделки
Ключом записи является символ
Время записи соответствует времени сделки
--------------------------------------------------------------------------------
Проблема фидеров: Со временем есть проблемы. Джойнить сделки из разных фидеров
по времени вероятно не получится. Разные сделки могут быть датированы
одинаковым временем. В зависимости от того, как будет работать джойн, по времени
будут джойниться разные сделки в зависимости от времени поступления. Походу, там
джойнить вообще не особо получится. Если только по номерам сделок. Можно
попробовать слушать несколько топиков от фидеров и обрабатывать только одну
первую сделку, независимо от источника.
--------------------------------------------------------------------------------

Запись начинается с заголовка.
Обозначим 4 кейса за счет младших 2х бит:
0 - Служебная управляющая запись. Зарезервировано.
1 - стандартная запись:
  * 6 оставшихся бит первого байта - значение объема;
  * Следующий 1 байт точность дес. знаков 4 младшие биты на цену и 4 старшие
    на объем соотв.
    Допустимая точность в пределах 0-15 знаков;
  * Затем 2 байта значение цены
  Размер записи фиксирован 4 байта. Подходит для большого кол-ва сделок
  со сток-маркета.
2 - малая расширенная запись:
  * остаток 6 бит используются для определения длины компонентов в байтах
    по 3 бита соответственно. Таким образом можно закодировать длину до 8 байт
    на компонент (0 считается за 1, то есть при записи из длины вычитается 1);
  * Следующий 1 байт точность дес. знаков по 4 бита на цену и объем соотв.;
  * Далее следуют байты цены в количестве указанном в заголовке;
  * Далее следуют байты объема в количестве указанном в заголовке;
  Минимальный размер записи 4 байта: 1 заголовок, 2 точность, 3 цена, 4 объем.
  Этот тип заменит тип 1 если объем не влазит в 6 бит, а цена в пределах 256.
  Максимальный размер записи 18 байт.
3 - Широкая запись. Зарезервировано. Пока не появятся данные типа крипты, смысла
  нет заморачиваться. Сйечас завершать работу при обнаружении.
 
На основании анализа возможных вариантов реализации принято решение добавить
в сделку информацию о точности цены и объема в десятичных знаках после точки.
Такой подход увеличит объем занятой памяти, но значительно упростит и ускорит
последующую обработку. При этом, для дальнейшей обработки не потребуется
никакой дополнительной информации типа значения атрибутов инструмента в
определенный момент времени, получение которых для каждой сделки влечет массу
дополнительных вычислительных расходов. В базовом варианте для этих целей
выделяется дополнительный байт: по 4 бита на точность цены и объема соотв.
4 бит недостаточно для покрытия всех кейсах в пределах long, так как 4 бита
позволяет кодировать до 16 элементов (диапазон 0-15), а максимальное количество
символов лонга в случае десятичного представления равна 20. Однако 15 достаточно
для подавляющего количества случаев. Подразумевается, что текущая реализация
предназначена для источников данных, укладывающихся в типы записи: стандартная и
малая расширенная. В случае, если 4 бит недостаточно для указания точности,
данные должны будут сохраняться в виде широкой записи. На момент реализации
информацию о подобных проблемах следует направлять в специальный топик
уведомлений.

================================================================================
Бинарный формат представления свечей

Данный формат предназначен для хранения в целях последующих рассчетов.
Свеча представляет собой кортеж 5 элементов: цен открытия, максимальной,
минимальной, закрытия и суммарного объема сделок за период.
Период группировки определяется топиком.
Ключом записи является символ
Время записи соответствует времени сделки

Младшие 2 бита - тип формата записи
0 - Служебная управляющая запись. Зарезервировано.
1 - Стандартная запись. 
  * 3 Бита определяют длину значения объема в байтах.
  * 3 Бита зарезервировано.
  * Следующий 1 байт кодирует точность цены и объема в десятичных знаках после
  точки (см. формат сделки)
  * Следующий 1 байт кодирует тип и длину цен открытия и максимума:
    - 1 бит - зарезервирован
    - 3 бита - длина цены открытия байт
    - 1 бит определяет способ кодирования максимума цены: 0 - абсолютное
      значение; 1 - смещение относительно цены открытия
    - 3 бита длина значения максимальной цены в байтах
  * Следующий 1 байт кодирует тип и длину цен минимума и закрытия. На каждый
    компонент отводится по 4 бита, который интерпретируются одинаково:
    - 1 бит определяет способ кодирования: 0 - абсолютное, 1 - относительно
      цены открытия
    - 3 бита содержат длину значения цены в байтах (см. формат сделки)
  * Байты значения цены открытия в количестве, указанном в заголовке
  * Байты значения максимальной цены
  * Байти значения минимальной цены
  * Байты значения цены закрытия
  * Байты значения суммарного объема
  Размер заголовка: 4 байта (заголовок, точность, параметры OH, параметры LC).
  Минимальный размер записи 9 байт, максимальный: 44.
2 - Зарезервировано.
3 - Зарезервировано.

Переполнение здесь может быть только при суммировании объема.
Использовать Math.addExact

