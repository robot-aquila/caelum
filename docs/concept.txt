TODO: Нужно продумать горячий запуск/останов фидера? Продумать механизм,
как работать с дублирующими фидерами. Но в MVP этим заморачиваться вероятно не
стоит? Можно сделать сохранение в отдельные топики на фидер, обеспечивая тем
самым необходимую избыточность данных. Консумер может отслеживать группу
топиков, комбинируя в случае необходимости данные из разных фидеров. Потерь
данных не будет, пока работает хотя бы один фидер. Можно конекаться к разным
конечным точкам, так что если даже у провайдера будет сбой на одном сервере,
система поедет на оставшемся фидере.

TODO: Нужен список инструментов.

Реализация узлов.

1) Наиболее быстрый для мамбы, взять aquila-transaq, навешать на терминальные
события отлов сделок, конвертировать их в json вида [ id, time, price, vol ]
и пулять в кафку под разные топики, соответствующие разным инструментам.
Подписываться при старте на все символы. Делать реконнект и реподписку при
обрывах. В какие моменты и какими событиями обновляется список инструментов
пока неизвестно. Даст ли провайдер подписаться на 40к фидов и влезет ли такой
объем в один процесс, также неизвестно.

2) Заюзать kafka streming API. Навешать на фиды сначала агрегатор, который из
избыточных данных восстановит последовательность сделок, а затем агрегатор
который из тиковых данных налепит M1 свечки и выше. Вероятно, выше D1 сохранять
свечки особого смысла нет, Но можно и сохранить и тогда на выходных узлах вообще
не будет никакой логики кроме чтения и они будут работать максимально быстро.
Здесь так же надо построить индексы, которые позволят быстро ориентироваться
в последовательности и определять с какой записи какой временной период
начинается. Индексы еще следует продумать.

3) Видимо, REST апи для получения исторических данных. Можно взять spring boot
и налепить контроллеров. Всего их будет два:
1) Для получения тиковых данных за период от и до
2) Для получения свечек. Тут кроме периода от клиента понадобится еще таймфрейм.
Для MVP интерфейсы делать открытыми, а потом навешивать авторизацию.
Для real-time REST не подходит. Если нужно реалтайм, то нужны потоковые
протоколы.


TODO: Ключи можно использовать для раскидывания данных по партициям. Для сделок
это, видимо, не подходит. Но можно раскидать свечки.

TODO: Подзадача 1! Сборка данных из нескольких подающих фидеров в одну
последовательность сделок в реальном времени. Перезаписывать по ключам нельзя
ибо это меняет позицию.


TODO: кафка
TimestampExtractor 
processing.guarantee config value to exactly_once
Out-of-Order Handling (запоздавшие таймстампы)
See num.standby.replicas in the Kafka Streams Configs section.



TODO:

Нужна полная инфа о сделках для реплея.

Индексы:
Индексы надо хранить отдельно. Тогда можно легко расширять и добавлять новые.
Если хранить вместе, то придется при каждом изменении структуры индексов
перелопачивать уже существующие.

Допустим, минутный индекс на сделки даст ровно 24*60=1440 записей в сутки.
Индекс за день можно хранить целиком в бинарном виде, читать в виде отдельных
записей. Для указания на конкретный день можно сделать индекс второго уровня,
но лучше попробовать связать с индексом записи в партиции.
Для мосбиржи можно сжать.

Проблема с потоковым хранением индексов заключается в невозможности перезаписи
произвольной записи.



С индексами решено - кафка поддерживает. см. Consumer#offsetsForTimes

Таймстампы есть, индексы есть, ключи = тикеры.
По ключу можно определить партицию (забыл для чего это нужно)

Осталось разобраться:

*) Как хранить сделки - в отдельных топиках или в общем?
У общего есть плюсы:
 - можно разбивать на партиции и не париться вообще про топики
 - можно будет делать стримы из одного топика - они будут норм масштабироваться
Но и минусы:
 - данные разных символов будут смешаны и придется фильтровать на выдаче по
 символу. Хотя, если будет хорошо раскидано по партициям, то должно быть норм.
 - нельзя определить список символов обзором топиков
В случае отдельных топиков минусы:
 - непонятно как роутить из общей очереди если работать процессором
Плюсы:
 - топик содержит тикер и можно напрямую обратиться к данным тикера
 - данные хранятся обособлено и не будет оверхеда на пропуск ненужных символов.
 Но если будет много партиций, то это будет небольшая проблема, так как символы
 будут раскиданы по партициям.
 
*) Список инструментов.
Можно сделать таблицу в которую собирать инфу о прокаченных записях.
Но для поиска по ключу нужно будет отбирать стримом. Неизвестно насколько
это будет эффективно.

Насчет того, откуда брать данные для списка инструментов. Делать эту таблицу на
базе сделок вероятно смысла нет. Сделки у нас существуют отдельно и могут жить
самостоятельно. Хотя для дальнейшего процессинга уже нужна точность. В реальном
времени все равно сначала мы получаем параметры инструмента, а затем идут тики.
Но что делать, если какой то лаг будет при получении параметров? Кстати, для
параметров тоже можно сделать широкую таблицу (или хотя бы таблицу с точностью
и размером тика). В общем, список инструментов надо строить в процессе
сбора обновлений атрибутов.

Для списка инструментов compacted topic. Возможно из таблицы. Итак:
фидер слушает изменение состояний инструментов и постит события обновлений
в топик обновлений свойств. Ключами являются тикеры. Таймпстампы - время
соответствующее времени обновления параметров. Значением - карта обновленных
атрибутов. Этот топик будет использоваться для отбора обновлений на дату.
На этот топик навешиваем процессор, который маппит все в таблицу атрибутов
инструмента на последний момент.

Обновлений туда будет немного. Сделать 1 партицию? С 1 партицией чтение будет
идеально простым. С множеством партиций мы получим масштабирование, но как их
потом собирать в одну?

Таблица ведь не упорядочена. Для списка инструментов надо гарантировать
несменяемый порядок. Значит надо сделать через доптаблицу отдельный список.
Можно какое нибудь фиктивное значение типа 1 и убедиться, что обновления
единиц не будет вызывать появление записей в результирующем топике.

Итого:
1) топик с обновлениями инструментов с ключами-тикерами, хранит дельты
датированные временем обновления. Используется для реплея и восстановления.
2) таблица текущего состояния инструментов с ключами-тикерами, хранит
полное состояние, датированное временем последнего обновления. Используется
процессорами для быстрого получения текущих атрибутов.
3) таблица-список тикеров. 

Все компоненты:
- Список инструментов
- Поток обновлений атрибутов инструмента
- Поток сделок
- Поток свечей M1
- Фидер ММВБ
- Сериализатор сделок

Список инструментов.
1 партиция. Максимальное время хранения.
Записи добавляются в порядке появления инструментов в системе.
Источник - любой топик, где ключи - полный символ.
На основе потока из этого топика
groupByKey().count().filter((k, v) -> { v == 1 }).toStream().to(target-topic);
В результате топик будет заполняться записями, где ключи это символы.
Порядок записей будет постоянным и к ним можно обращаться по смещению.

Поток обновлений атрибутов инструмента
Произвольное кол-во партиций. Максимальное время хранения.
Первая запись содержит снепшот. Последующие записи содержат список измененных
атрибутов и новые значения. Ключи - полный символ. Время - время обновления
атрибутов.

Фидеры обновлений атрибутов инструмента

================================================================================
Бинарный формат представления сделки

Сырой формат оптимизирован как по памяти, так и под скорость.
Нам нужно хранить пару значений: цену и количество сделки
Ключом записи является символ
Время записи соответствует времени сделки
--------------------------------------------------------------------------------
Проблема фидеров: Со временем есть проблемы. Джойнить сделки из разных фидеров
по времени вероятно не получится. Разные сделки могут быть датированы
одинаковым временем. В зависимости от того, как будет работать джойн, по времени
будут джойниться разные сделки в зависимости от времени поступления. Походу, там
джойнить вообще не особо получится. Если только по номерам сделок. Можно
попробовать слушать несколько топиков от фидеров и обрабатывать только одну
первую сделку, независимо от источника.
--------------------------------------------------------------------------------
 
На основании анализа возможных вариантов реализации принято решение добавить
в сделку информацию о точности цены и объема в десятичных знаках после точки.
Такой подход увеличит объем занятой памяти, но значительно упростит и ускорит
последующую обработку. При этом, для дальнейшей обработки не потребуется
никакой дополнительной информации типа значения атрибутов инструмента в
определенный момент времени, получение которых для каждой сделки влечет массу
дополнительных вычислительных расходов. В базовом варианте для этих целей
выделяется дополнительный байт: по 4 бита на точность цены и объема соотв.
4 бит недостаточно для покрытия всех кейсах в пределах long, так как 4 бита
позволяет кодировать до 16 элементов (диапазон 0-15), а максимальное количество
символов лонга в случае десятичного представления равна 20. Однако 15 достаточно
для подавляющего количества случаев. Подразумевается, что текущая реализация
предназначена для источников данных, укладывающихся в типы записи: стандартная и
малая расширенная. В случае, если 4 бит недостаточно для указания точности,
данные должны будут сохраняться в виде широкой записи. На момент реализации
информацию о подобных проблемах следует направлять в специальный топик
уведомлений.

Записи о сделках могут храниться в разных форматах и декодироваться в объекты
разных классов в зависимости от возможности хранения в том или ином виде.
Это необходимо для того, что бы обеспечить хранение в максимально компактном
виде и иметь возможность оставаться в рамках простых вычислений там где это
возможно. Тип класса сделки определяется как по бинарному представлению, так
через соответствующий метод экземпляра сделки.

Типы:
RESERVED_0 - зарезервировано
LONG_UNKNOWN - указывает на неопределенный тип кодирования (при создании)
LONG_COMPACT - для сделок с ценой в пределах 0-65535 и объемом в пределах 0-63
    и кол-вом десячитных знаков в пределах 0-15
LONG_REGULAR - для сделок с ценой и объемом в пределах от -2^63 до 2^63-1
    и кол-вом десячитных знаков в пределах 0-15
RESERVED_1 - зарезервировано

Запись начинается с заголовка.
2 младшие бита кодируют тип записи:
0x00 - RESERVED_0 - кодировщик выбрасывает исключение
0x01 - LONG_COMPACT - кодирует сделку типа LBTrade 
0x02 - LONG_REGULAR - кодирует сделку типа LBTrade
0x03 - RESERVED_1 - кодировщик выбрасывает исключение

LONG_COMPACT
  * 6 оставшихся бит первого байта - значение объема 0-63;
  * Следующий 1 байт кодирует количество десятичных знаков для компонентов:
    4 младших бита на цену и 4 старших бит на объем соотв.
  * Затем следуют 2 байта значения цены 0-65536
  Размер записи фиксирован 4 байта. Подходит для большого кол-ва сделок
  со сток-маркета.

LONG_REGULAR
  * 6 оставшихся бит используются для определения длины компонентов в байтах
    по 3 бита на цену (биты 2-4 включительно) и объем (биты 5-7) соответственно.
    Длина компонентов не может занимать менее 1 байта. Максимальная длина
    компонента 8 байт. Для кодировки этой длины в трех битах, значение длины
    компонентов перед записью уменьшается на единицу. Таким образом,
    закодированное значение 0 соответствует длинне в 1 байт, а закодированное
    значение 7 - длинне 8 байт.
  * Следующий 1 байт кодирует количество десятичных знаков для компонентов:
    4 младших бита на цену и 4 старших бит на объем соотв.
  * Далее следуют байты цены в количестве указанном в заголовке;
  * Далее следуют байты объема в количестве указанном в заголовке;
  Минимальный размер записи 4 байта: по байту на заголовок, точность, цену и
  объем.

================================================================================
Бинарный формат представления свечей

Данный формат предназначен для хранения в целях последующих рассчетов.
Свеча представляет собой кортеж 5 элементов: цен открытия, максимальной,
минимальной, закрытия и суммарного объема сделок за период. Для представления
объема может быть использован BigInteger, если типа long не достаточно.
Период группировки определяется топиком.
Ключом записи является символ
Время записи соответствует времени сделки

При суммировании объема на базе long можем получить переполнение. Можно
использовать Math.addExact, отлавливать исключение и инициировать BigInteger.

Типы:
RESERVED_0 - зарезервировано
LONG_UNKNOWN - указывает на неопределенный тип кодирования (при создании)
LONG_REGULAR - для свечей с ценами и объемом в пределах от -2^63 до 2^63-1
    и кол-вом десячитных знаков в пределах 0-15
LONG_WIDEVOL - для свечей с ценами в пределах от -2^63 до 2^63-1, значением
    объема в виде BigInteger и кол-вом десячитных знаков в пределах 0-15
 
Запись начинается с заголовка.
2 младшие бита кодируют тип записи:
0x00 - RESERVED_0 - кодировщик выбрасывает исключение
0x01 - LONG_COMPACT - кодировщик выбрасывает исключение
0x02 - LONG_REGULAR - кодирует свечку где все значения в пределах типа long
0x02 - LONG_WIDEVOL - кодирует свечку где для объема исп. BigInteger

LONG_COMPACT/LONG_REGULAR
  * - Для LONG_REGULAR 3 следующих бита определяют длину значения объема
    в байтах -1.
    - Для LONG_WIDEVOL эти биты включены, а тип значения объема определяется по
    остаточной длине записи. Если остаточная длина > 8, то при декодировании
    используется BigInteger.
  * 3 Бита зарезервировано.
  * Следующий 1 байт кодирует точность цены и объема в десятичных знаках после
  точки (см. формат сделки)
  * Следующий 1 байт кодирует тип и длину цен открытия и максимума:
    - 1 бит - зарезервирован
    - 3 бита - длина цены открытия байт (минус 1)
    - 1 бит определяет способ кодирования максимума цены: 0 - абсолютное
      значение; 1 - смещение относительно цены открытия
    - 3 бита длина значения максимальной цены в байтах минус 1
  * Следующий 1 байт кодирует тип и длину цен минимума и закрытия. На каждый
    компонент отводится по 4 бита, который интерпретируются одинаково:
    - 1 бит определяет способ кодирования: 0 - абсолютное, 1 - относительно
      цены открытия
    - 3 бита содержат длину значения цены в байтах минус 1 (см. формат сделки)
  * Байты значения цены открытия в количестве, указанном в заголовке
  * Байты значения максимальной цены
  * Байти значения минимальной цены
  * Байты значения цены закрытия
  * Байты значения суммарного объема
  Размер заголовка: 4 байта (заголовок, точность, параметры OH, параметры LC).
  Минимальный размер записи 9 байт, максимальный: если используется long для
  представления объема - 44, и не определено, если используется тип BigInteger.


